---
title: "chapter5"
author: "Rumo Schilling"
date: "2023-02-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r}
library(nycflights13)
library(tidyverse)

```

```{r}
#| filter practice
#arrival delay 2 or more hrs
flights %>%
  filter(arr_delay >=2)
"arrives in Houston"
flights %>%
  filter(dest == "HOU" | dest =="IAH")
"from Delta,United or American"
flights %>%
  filter(carrier == "AA" |carrier == "UA" | carrier == "DL")
"Flew in the Summer"
flights %>%
  filter(month == "Juni" | month == "July" | month == "August")
"Arrived 2+ hrs late but did not depart late"
flights %>% 
  filter(arr_delay >=2 & dep_delay <= 0)
"Arrived 1+ hrs late, but made up at least half an hour"
flights %>%
  mutate(madeup = arr_delay - dep_delay) %>%
  filter(arr_delay >= 1 & madeup >= 0.5)
#
flights %>%
  filter(between(dep_time,0,6))

flights %>% 
  filter(is.na(dep_time))
# jeeze, that is a lot of NA. I suspect it will be that the cancelled flights
flights %>%
  filter(is.na(dep_time)) %>%
  select(dep_time,dep_delay,sched_arr_time,arr_delay,arr_time)
# Ig I am right.
```
> NA | True
Error: object 'True' not found
> NA | TRUE
[1] TRUE
> TRUE | FALSE
[1] TRUE
> FALSE | NA
[1] NA
> FALSE | FALSE
[1] FALSE
> NA | TRUE
[1] TRUE
Connected to your session in progress, last started 2023-Feb-06 16:00:31 UTC (23 minutes ago)
> NA & FALSE
[1] FALSE
> FALSE & TRUE
[1] FALSE
> NA & TRUE
[1] NA
 
 It appears to be that When asking for or, True is the thing we are looking for, and asking for and, then False is the desired result. When NA is there, the computer is confident if the desired result is already there(when something is true and false it is false, so it does not matter if NA is there, but if something is TRUE and NA, the output is NA). It is like transistor operators.
 
```{r}
#| label: 5.3.1
#| message: false

# 1.
flights %>% 
 arrange(desc(is.na(dep_time)),desc(dep_time))
#2.
flights %>% 
  arrange(desc(arr_delay)) %>%
  select(arr_delay)

flights %>% 
  arrange(arr_delay) %>%
  select(dep_delay,arr_delay)
#fastest flight
flights %>%
  mutate(speed = distance/air_time)%>%
  arrange(desc(speed))%>%
  select(speed,distance,air_time)
#farthest and shortest
flights %>% 
  summarise(far = max(distance),short = min(distance))
```
 5.4.1
 1. starts_with("dep") | starts_with("arr")
 2. ends_with("delay") | ends_with("time")
 and the combinations of that
 
```{r}
#| label: 5.4.1
 coolvars = c("distance","air_time")
 flights %>%
  select(starts_with("arr")|starts_with("dep"),arr_delay)
 flights %>%
   select(any_of(coolvars))
 flights %>%
  select(contains("TIME"))
```
As we see, the interpreter is smart enough to not show variables twice when selecting
furthermore, any_of is useful if you have a preprepared array of the variables you want to select multiple times, making the code readable by grouping variables.

contains is not case sensitive(wee)
5.5.2
```{r}
#| label: 5.5.2
flights %>%
  mutate(continuous_dep_time = (dep_time %/% 100)*60 + dep_time %% 100) %>%
  mutate(continuous_sched_arr_time = (sched_arr_time %/% 100)*60 + sched_arr_time %% 100) %>%
  select(continuous_dep_time,dep_time,continuous_sched_arr_time,sched_arr_time)
flights %>%
  select(dep_time,sched_dep_time,dep_delay)
flights %>%
  mutate(mostdelayed = min_rank(desc(dep_delay))) %>%
  arrange(mostdelayed) %>%
  select(mostdelayed,dep_delay)
sin(0)
```
For the second task, the noncontinous reprensentation makes it so that the - does not work. I
would have to transform it like in 1.
For, 3 the variables are excactly related like I thought, that delay = time- sched_time. Beautiful!
Min rank ranks like in sport, i.e if two are tied for 2nd place, the ranking is 1,2,2,4. For depature delay, this is luckily irrelevant
R seems to include all the trig functions, according to the documentation

```{r}
#| label: 5.6.7
# 2
not_cancelled <- flights %>% 
  filter(!is.na(dep_delay), !is.na(arr_delay))
not_cancelled %>%
  group_by(dest) %>%
  summarise(n = n())
not_cancelled %>%
  count(dest)
not_cancelled %>% 
  count(tailnum, wt = distance)
not_cancelled %>% 
  group_by(tailnum) %>%
  summarise( dis = mean(distance)* n())
# 4
flights %>%
  mutate(cancelled = 1 * is.na(arr_time)) %>%
  group_by(month,day) %>%
  summarise(cancelledperc = mean(cancelled),mean_dep_delay = mean(dep_delay,na.rm = TRUE),mean_arr_delay = mean(arr_delay,na.rm = TRUE))%>%
ggplot(aes(x = mean_arr_delay,y = cancelledperc)) + 
  geom_point()+
  geom_smooth()
flights %>%
  mutate(cancelled = 1 * is.na(arr_time)) %>%
  group_by(month,day) %>%
  summarise(cancelledperc = mean(cancelled),mean_dep_delay = mean(dep_delay,na.rm = TRUE),mean_dep_delay = mean(dep_delay,na.rm = TRUE))%>%
ggplot(aes(x = mean_dep_delay,y = cancelledperc)) + 
  geom_point()+
  geom_smooth()

# 5
not_cancelled%>%
  group_by(carrier) %>%
  summarise(mean_arr_delay = mean(arr_delay),n = n()) %>%
  filter(n>50)%>%
  arrange(desc(mean_arr_delay))
  not_cancelled%>%
  group_by(dest) %>%
  summarise(mean_arr_delay = mean(arr_delay),n = n()) %>%
  filter(n>50)%>%
  arrange(desc(mean_arr_delay))
rport_avg_delay <- not_cancelled%>%
  mutate(desti = dest) %>%
  group_by(desti) %>%
  summarise(mean_arr_delay = mean(arr_delay),n = n())
not_cancelled%>%
  mutate(desti = dest) %>%
  group_by(dest) %>%
  summarise(mean_arr_delay = mean(arr_delay),n = n())
#now computing in relation to destination
not_cancelled%>%
  #mutate(delay_by_airport = arr_delay * rport_avg_delay$mean_arr_delay[rport_avg_delay$dest ==dest]) %>%
  count(carrier,wt = arr_delay * rport_avg_delay$mean_arr_delay[rport_avg_delay$dest ==dest])
flights %>%
  count(dest,sort = TRUE)
    
```
arr_time is the most important column to determine if the flight was cancelled. There seems to be a positive correlation between cancelled flights and arr delay, but a stronger(and kind of weirder correlation) between dep delay and cancelled flights. Also, the day where they cancelled 50% of the flights is impressive. How do you do that? 
I think that disentangling the airplane from the airport is pretty hard, as if one airport gets dominated by a bad carrier, we cant really fault the airport. The only solution I could find was just to take the average of the airport and multiply it by the flight  The sort argument orders the counts by maximum. How to sort in descending order is not in the documentation.